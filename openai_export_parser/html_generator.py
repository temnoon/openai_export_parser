"""
HTML Generator for OpenAI Export Parser

Generates standalone HTML files for viewing conversations with:
- Embedded JSON data (no CORS issues)
- Markdown rendering (marked.js)
- LaTeX math (KaTeX)
- Code syntax highlighting (highlight.js)
- Fully portable (works offline, can copy single folder)
"""

import json
import os
from datetime import datetime


class HTMLGenerator:
    """Generates HTML viewers for conversations."""

    def __init__(self):
        pass

    def generate_conversation_html(self, conversation, media_files=None, assets=None, folder_name="", media_mapping=None):
        """
        Generate a standalone HTML file for a conversation.

        Args:
            conversation: Conversation dict with mapping, messages, metadata
            media_files: List of media filenames in media/ folder
            assets: List of asset filenames in assets/ folder
            folder_name: Name of the conversation folder (for navigation)
            media_mapping: Dict mapping original filename -> hashed filename

        Returns:
            HTML string
        """
        media_files = media_files or []
        assets = assets or []
        media_mapping = media_mapping or {}

        # Extract conversation metadata
        title = conversation.get('title', 'Untitled Conversation')
        create_time = conversation.get('create_time')
        update_time = conversation.get('update_time')
        conv_id = conversation.get('conversation_id') or conversation.get('id', 'unknown')

        # Format timestamps
        created_date = self._format_timestamp(create_time) if create_time else 'Unknown'
        updated_date = self._format_timestamp(update_time) if update_time else 'Unknown'

        # Count messages
        mapping = conversation.get('mapping', {})
        message_count = sum(1 for node in mapping.values() if node.get('message'))

        # Build asset_pointer -> filename mapping for size-matched images
        # This maps (asset_pointer, size) pairs to actual filenames
        asset_pointer_map = self._build_asset_pointer_map(conversation, media_files, media_mapping)

        # Serialize conversation data for embedding
        conv_json = json.dumps(conversation, indent=2, ensure_ascii=False)

        html_template = f'''<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{self._escape_html(title)}</title>

    <!-- External Libraries (CDN) -->
    <script src="https://cdn.jsdelivr.net/npm/marked@11.0.0/marked.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <style>
{self._get_css()}
    </style>

    <!-- Detect dark mode preference BEFORE page render to avoid flash -->
    <script>
        (function() {{
            const stored = localStorage.getItem('darkMode');
            const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;

            // Priority: localStorage > system preference
            if (stored === 'enabled' || (stored === null && prefersDark)) {{
                document.documentElement.classList.add('dark-mode');
            }}
        }})();
    </script>
</head>
<body>
    <div class="container">
        <header>
            <div class="header-content">
                <div class="nav-buttons">
                    <a href="../index.html" class="btn btn-secondary">‚Üê Back to Index</a>
                    <button onclick="toggleDarkMode()" class="btn btn-secondary">üåì Toggle Theme</button>
                </div>
                <h1>{self._escape_html(title)}</h1>
                <div class="metadata">
                    <span>üìÖ Created: {created_date}</span>
                    <span>üìù Updated: {updated_date}</span>
                    <span>üí¨ Messages: {message_count}</span>
                    {f'<span>üñºÔ∏è Media: {len(media_files)}</span>' if media_files else ''}
                    {f'<span>üìÑ Assets: {len(assets)}</span>' if assets else ''}
                </div>
            </div>
        </header>

        <main id="conversation-container">
            <div class="loading">Loading conversation...</div>
        </main>

        <footer>
            <p>Generated by <a href="https://github.com/anthropics/openai-export-parser" target="_blank">OpenAI Export Parser</a></p>
            <p class="conv-id">Conversation ID: {conv_id}</p>
        </footer>
    </div>

    <!-- Embedded Conversation Data -->
    <script id="conversation-data" type="application/json">{conv_json}</script>
    <script id="media-files-data" type="application/json">{json.dumps(media_files)}</script>
    <script id="asset-files-data" type="application/json">{json.dumps(assets)}</script>
    <script id="media-mapping-data" type="application/json">{json.dumps(media_mapping)}</script>
    <script id="asset-pointer-map-data" type="application/json">{json.dumps(asset_pointer_map)}</script>

    <!-- Rendering Script -->
    <script>
        // Load JSON data from script tags
        const conversationData = JSON.parse(document.getElementById('conversation-data').textContent);
        const mediaFiles = JSON.parse(document.getElementById('media-files-data').textContent);
        const assetFiles = JSON.parse(document.getElementById('asset-files-data').textContent);
        const mediaMapping = JSON.parse(document.getElementById('media-mapping-data').textContent);
        const assetPointerMap = JSON.parse(document.getElementById('asset-pointer-map-data').textContent);
    </script>

    <script>
{self._get_javascript()}
    </script>
</body>
</html>'''

        return html_template

    def _get_css(self):
        """Get CSS styles for the conversation viewer."""
        return '''
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f5f5f5;
            --bg-user: #e3f2fd;
            --bg-assistant: #f5f5f5;
            --bg-tool: #fff3e0;
            --text-primary: #212121;
            --text-secondary: #666666;
            --border-color: #e0e0e0;
            --accent-color: #1976d2;
            --code-bg: #f0f0f0;
            --code-text: #1a1a1a;
            --table-border: #d0d0d0;
            --table-header-bg: #e8e8e8;
        }

        html.dark-mode,
        html.dark-mode body {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --bg-user: #1e3a5f;
            --bg-assistant: #2d2d2d;
            --bg-tool: #3d2e1f;
            --text-primary: #e0e0e0;
            --text-secondary: #b0b0b0;
            --border-color: #444444;
            --accent-color: #64b5f6;
            --code-bg: #2d2d2d;
            --code-text: #e0e0e0;
            --table-border: #505050;
            --table-header-bg: #3a3a3a;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            transition: background-color 0.3s, color 0.3s;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background-color: var(--bg-secondary);
            padding: 30px;
            border-radius: 12px;
            margin-bottom: 30px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .header-content h1 {
            font-size: 2em;
            margin-bottom: 15px;
            color: var(--accent-color);
        }

        .nav-buttons {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 10px 20px;
            border-radius: 6px;
            text-decoration: none;
            display: inline-block;
            font-weight: 500;
            transition: all 0.2s;
            border: none;
            cursor: pointer;
            font-size: 0.9em;
        }

        .btn-secondary {
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover {
            background-color: var(--accent-color);
            color: white;
        }

        .metadata {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        main {
            min-height: 400px;
        }

        .message {
            margin-bottom: 24px;
            padding: 20px;
            border-radius: 12px;
            background-color: var(--bg-secondary);
            border-left: 4px solid var(--border-color);
            transition: all 0.2s;
        }

        .message:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .message.user {
            background-color: var(--bg-user);
            border-left-color: var(--accent-color);
        }

        .message.assistant {
            background-color: var(--bg-assistant);
            border-left-color: #4caf50;
        }

        .message.tool {
            background-color: var(--bg-tool);
            border-left-color: #ff9800;
        }

        .message-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        .message-author {
            font-weight: 600;
            color: var(--accent-color);
        }

        .message-time {
            font-size: 0.85em;
        }

        .message-content {
            color: var(--text-primary);
        }

        .message-content h1, .message-content h2, .message-content h3 {
            margin-top: 1em;
            margin-bottom: 0.5em;
            color: var(--text-primary);
        }

        .message-content h1 { font-size: 1.8em; }
        .message-content h2 { font-size: 1.5em; }
        .message-content h3 { font-size: 1.2em; }

        .message-content p {
            margin-bottom: 1em;
        }

        .message-content code {
            background-color: var(--code-bg);
            color: var(--code-text);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
            border: 1px solid var(--table-border);
        }

        .message-content pre {
            background-color: var(--code-bg);
            color: var(--code-text);
            padding: 15px;
            border-radius: 6px;
            overflow-x: auto;
            margin: 1em 0;
            border: 1px solid var(--table-border);
        }

        .message-content pre code {
            background-color: transparent;
            padding: 0;
            border: none;
        }

        .message-content ul, .message-content ol {
            margin-left: 2em;
            margin-bottom: 1em;
        }

        .message-content blockquote {
            border-left: 4px solid var(--accent-color);
            padding-left: 1em;
            margin: 1em 0;
            color: var(--text-secondary);
            font-style: italic;
        }

        .message-content img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            margin: 1em 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .audio-message {
            margin: 1em 0;
            padding: 12px;
            background-color: var(--code-bg);
            border-radius: 8px;
            border: 1px solid var(--table-border);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .audio-message audio {
            flex: 1;
            height: 32px;
        }

        .audio-duration {
            color: var(--text-secondary);
            font-size: 0.85em;
            white-space: nowrap;
        }

        .message-content a {
            color: var(--accent-color);
            text-decoration: none;
        }

        .message-content a:hover {
            text-decoration: underline;
        }

        .math-display {
            margin: 1em 0;
            overflow-x: auto;
        }

        .tool-call {
            background-color: var(--code-bg);
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0;
            font-size: 0.9em;
        }

        .metadata-section {
            margin-top: 15px;
            padding: 10px;
            background-color: var(--code-bg);
            border-radius: 6px;
            font-size: 0.85em;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: var(--text-secondary);
        }

        footer {
            margin-top: 50px;
            padding: 20px;
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.9em;
            border-top: 1px solid var(--border-color);
        }

        footer a {
            color: var(--accent-color);
            text-decoration: none;
        }

        .conv-id {
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
            margin-top: 5px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            header {
                padding: 20px;
            }

            .header-content h1 {
                font-size: 1.5em;
            }

            .metadata {
                flex-direction: column;
                gap: 10px;
            }
        }

        @media print {
            .nav-buttons {
                display: none;
            }

            .message {
                break-inside: avoid;
            }
        }

        /* Image gallery styles */
        .message-images {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }

        .message-images img {
            width: 100%;
            height: 200px;
            object-fit: cover;
            cursor: pointer;
            border-radius: 8px;
            transition: transform 0.2s, box-shadow 0.2s;
            border: 2px solid transparent;
        }

        .message-images img:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            border-color: var(--accent-color);
        }

        /* Single image (not in gallery) */
        .message-content img:not(.message-images img) {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .message-content img:not(.message-images img):hover {
            transform: scale(1.02);
        }

        /* Lightbox overlay */
        .lightbox {
            display: none;
            position: fixed;
            z-index: 9999;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            animation: fadeIn 0.3s;
        }

        .lightbox.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .lightbox-content {
            max-width: 90%;
            max-height: 90%;
            object-fit: contain;
            animation: zoomIn 0.3s;
        }

        @keyframes zoomIn {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .lightbox-close {
            position: absolute;
            top: 20px;
            right: 40px;
            font-size: 40px;
            font-weight: bold;
            color: white;
            cursor: pointer;
            background: none;
            border: none;
            padding: 10px 20px;
            transition: color 0.2s;
            z-index: 10000;
        }

        .lightbox-close:hover {
            color: #ff4444;
        }

        .lightbox-prev,
        .lightbox-next {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            font-size: 50px;
            font-weight: bold;
            color: white;
            cursor: pointer;
            background: rgba(0, 0, 0, 0.5);
            border: none;
            padding: 20px;
            transition: background 0.2s;
            user-select: none;
            z-index: 10000;
        }

        .lightbox-prev:hover,
        .lightbox-next:hover {
            background: rgba(0, 0, 0, 0.8);
        }

        .lightbox-prev {
            left: 0;
        }

        .lightbox-next {
            right: 0;
        }

        .lightbox-prev:disabled,
        .lightbox-next:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .lightbox-prev:disabled:hover,
        .lightbox-next:disabled:hover {
            background: rgba(0, 0, 0, 0.5);
        }

        .lightbox-caption {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 0.9em;
        }

        /* Table styles with distinct borders and header shading */
        .message-content table {
            border-collapse: collapse;
            width: 100%;
            margin: 1em 0;
            border: 2px solid var(--table-border);
            background-color: var(--bg-primary);
        }

        .message-content th {
            background-color: var(--table-header-bg);
            color: var(--text-primary);
            font-weight: 600;
            padding: 12px;
            text-align: left;
            border: 1px solid var(--table-border);
        }

        .message-content td {
            padding: 10px 12px;
            border: 1px solid var(--table-border);
            color: var(--text-primary);
        }

        .message-content tr:nth-child(even) {
            background-color: var(--bg-secondary);
        }

        .message-content tr:hover {
            background-color: var(--table-header-bg);
        }
        '''

    def _get_javascript(self):
        """Get JavaScript for rendering the conversation."""
        return '''
        // Configure marked.js for Markdown rendering
        marked.setOptions({
            breaks: true,
            gfm: true,
            headerIds: false,
            mangle: false,
        });

        // Dark mode toggle
        function toggleDarkMode() {
            document.documentElement.classList.toggle('dark-mode');
            const isDark = document.documentElement.classList.contains('dark-mode');
            localStorage.setItem('darkMode', isDark ? 'enabled' : 'disabled');
        }

        // Escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Format timestamp
        function formatTimestamp(timestamp) {
            if (!timestamp) return 'Unknown';
            const date = new Date(timestamp * 1000);
            return date.toLocaleString();
        }

        // Convert [file-...] markdown links to proper <img> tags
        function convertMediaLinks(text) {
            // Match [file-...] patterns and convert to image tags
            // Pattern: [file-XXXXX] or [file-XXXXX_filename.ext]
            return text.replace(/\\[file-([^\\]]+)\\]/g, (match, fileRef) => {
                // Extract the file-ID part (before underscore if present)
                const fileId = fileRef.split('_')[0];
                const fullRef = 'file-' + fileRef;

                // Try to find in mediaMapping
                for (const [originalName, hashedName] of Object.entries(mediaMapping)) {
                    if (originalName.includes('file-' + fileId) || originalName === fullRef + '.webp' || originalName === fullRef + '.png' || originalName === fullRef + '.jpeg' || originalName === fullRef + '.jpg') {
                        return `<img src="media/${hashedName}" alt="Image" loading="lazy" style="max-width: 100%; height: auto;">`;
                    }
                }

                // Also try UUID patterns (for DALL-E generations)
                // If the fileRef looks like a UUID
                if (fileRef.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/i)) {
                    for (const [originalName, hashedName] of Object.entries(mediaMapping)) {
                        if (originalName.includes(fileRef)) {
                            return `<img src="media/${hashedName}" alt="Image" loading="lazy" style="max-width: 100%; height: auto;">`;
                        }
                    }
                }

                // If not found, return the original text (not as markdown)
                return `<em>[Image: file-${fileRef}]</em>`;
            });
        }

        // Process LaTeX in text
        function processLatex(text) {
            // First convert media links to proper image tags
            text = convertMediaLinks(text);

            // Protect code blocks first
            const codeBlocks = [];
            text = text.replace(/```[\\s\\S]*?```|`[^`]+`/g, (match) => {
                codeBlocks.push(match);
                return `__CODE_BLOCK_${codeBlocks.length - 1}__`;
            });

            // Process LaTeX with KaTeX-compatible delimiters
            // Priority: \\[ \\], \\( \\), $$, $ (in that order to avoid conflicts)

            // Block math: \\[ ... \\]
            text = text.replace(/\\\\\\[(.*?)\\\\\\]/gs, (match, math) => {
                try {
                    return '<div class="math-display">' + katex.renderToString(math, {
                        displayMode: true,
                        throwOnError: false
                    }) + '</div>';
                } catch (e) {
                    return match;
                }
            });

            // Inline math: \\( ... \\)
            text = text.replace(/\\\\\\((.*?)\\\\\\)/g, (match, math) => {
                try {
                    return katex.renderToString(math, {
                        displayMode: false,
                        throwOnError: false
                    });
                } catch (e) {
                    return match;
                }
            });

            // Block math: $$ ... $$
            text = text.replace(/\\$\\$([^$]+)\\$\\$/g, (match, math) => {
                try {
                    return '<div class="math-display">' + katex.renderToString(math, {
                        displayMode: true,
                        throwOnError: false
                    }) + '</div>';
                } catch (e) {
                    return match;
                }
            });

            // Inline math: $ ... $ (be careful with false positives)
            // Only match if $ is not preceded/followed by space or at start/end of word
            text = text.replace(/(?<!\\w)\\$(?!\\s)([^$\\n]+?)(?<!\\s)\\$(?!\\w)/g, (match, math) => {
                // Additional check: math should contain LaTeX-like content
                if (/[\\\\{}^_]/.test(math) || math.length > 2) {
                    try {
                        return katex.renderToString(math, {
                            displayMode: false,
                            throwOnError: false
                        });
                    } catch (e) {
                        return match;
                    }
                }
                return match;
            });

            // Restore code blocks
            text = text.replace(/__CODE_BLOCK_(\\d+)__/g, (match, index) => {
                return codeBlocks[parseInt(index)];
            });

            return text;
        }

        // Render message content
        function renderMessageContent(content) {
            if (!content) return '';

            let html = '';

            // Handle different content types
            if (content.content_type === 'text') {
                let text = Array.isArray(content.parts) ? content.parts.join('\\n') : (content.parts || '');

                // Check if text is JSON with prompt field (DALL-E prompts)
                try {
                    const parsed = JSON.parse(text);
                    if (parsed.prompt) {
                        // Extract and display just the prompt text
                        text = parsed.prompt;
                    }
                } catch (e) {
                    // Not JSON, continue with normal processing
                }

                // Process LaTeX first
                text = processLatex(text);

                // Then process Markdown
                html = marked.parse(text);

            } else if (content.content_type === 'multimodal_text') {
                const parts = content.parts || [];
                parts.forEach(part => {
                    if (typeof part === 'string') {
                        let text = processLatex(part);
                        html += marked.parse(text);
                    } else if (part && part.content_type === 'audio_transcription') {
                        // Render audio transcript text
                        const transcriptText = part.text || '';
                        const direction = part.direction || '';
                        if (transcriptText) {
                            let text = processLatex(transcriptText);
                            html += marked.parse(text);
                        }
                    } else if (part && part.content_type === 'audio_asset_pointer') {
                        // Render audio player for assistant audio
                        const assetPointer = part.asset_pointer || '';
                        const format = part.format || 'audio';
                        const metadata = part.metadata || {};
                        const duration = metadata.end || 0;

                        // Extract file hash from sediment:// URLs
                        const fileHashMatch = assetPointer.match(/sediment:\\/\\/(file_[a-f0-9]+)/);
                        const fileHash = fileHashMatch ? fileHashMatch[1] : '';

                        // Find the audio file
                        let audioFile = null;
                        if (fileHash) {
                            audioFile = mediaFiles.find(f => f.includes(fileHash));
                        }

                        if (audioFile) {
                            const durationText = duration > 0 ? ` (${Math.round(duration)}s)` : '';
                            html += `<div class="audio-message"><audio controls preload="metadata"><source src="media/${audioFile}" type="audio/${format}">Your browser does not support audio playback.</audio><span class="audio-duration">${durationText}</span></div>`;
                        }
                    } else if (part && part.content_type === 'real_time_user_audio_video_asset_pointer') {
                        // Render audio player for user audio in real-time conversations
                        const audioPointer = part.audio_asset_pointer;
                        if (audioPointer) {
                            const assetPointer = audioPointer.asset_pointer || '';
                            const format = audioPointer.format || 'audio';
                            const metadata = audioPointer.metadata || {};
                            const duration = metadata.end || 0;

                            // Extract file hash from sediment:// URLs
                            const fileHashMatch = assetPointer.match(/sediment:\\/\\/(file_[a-f0-9]+)/);
                            const fileHash = fileHashMatch ? fileHashMatch[1] : '';

                            // Find the audio file
                            let audioFile = null;
                            if (fileHash) {
                                audioFile = mediaFiles.find(f => f.includes(fileHash));
                            }

                            if (audioFile) {
                                const durationText = duration > 0 ? ` (${Math.round(duration)}s)` : '';
                                html += `<div class="audio-message"><audio controls preload="metadata"><source src="media/${audioFile}" type="audio/${format}">Your browser does not support audio playback.</audio><span class="audio-duration">${durationText}</span></div>`;
                            }
                        }
                    } else if (part && part.content_type === 'image_asset_pointer') {
                        // Get the asset pointer and extract identifiers
                        const assetPointer = part.asset_pointer || '';
                        const sizeBytes = part.size_bytes;
                        const metadata = part.metadata || {};
                        const dalle = metadata.dalle || {};
                        const genId = dalle.gen_id;

                        // Extract file-ID from asset_pointer (e.g., "file-service://file-XXXXX")
                        // Match file-ID after :// to avoid matching the protocol part
                        const fileIdMatch = assetPointer.match(/:\/\/(file-[A-Za-z0-9]+)/);
                        const fileId = fileIdMatch ? fileIdMatch[1] : '';

                        // Extract file hash from sediment:// URLs (e.g., "sediment://file_000000007674622f...")
                        const fileHashMatch = assetPointer.match(/sediment:\\/\\/(file_[a-f0-9]{32})/);
                        const fileHash = fileHashMatch ? fileHashMatch[1] : '';

                        // Try to find matching media file using multiple strategies
                        let mediaFile = null;

                        // Strategy 1: Try file hash (for sediment:// files)
                        if (fileHash) {
                            mediaFile = mediaFiles.find(f => f.includes(fileHash));
                        }

                        // Strategy 2: Try gen_id (for DALL-E generations with random names like "GHkfX9a0...")
                        if (!mediaFile && genId) {
                            mediaFile = mediaFiles.find(f => f.includes(genId));
                        }

                        // Strategy 3: Try file-ID (for user uploads like "file-XXXXX_filename.ext")
                        if (!mediaFile && fileId) {
                            mediaFile = mediaFiles.find(f => f.includes(fileId));
                        }

                        // Strategy 4: Try looking in mediaMapping by various keys
                        if (!mediaFile && (fileId || genId || fileHash)) {
                            // Look for the original filename in mediaMapping
                            for (const [originalName, hashedName] of Object.entries(mediaMapping)) {
                                if ((fileId && originalName.includes(fileId)) ||
                                    (genId && originalName.includes(genId)) ||
                                    (fileHash && originalName.includes(fileHash))) {
                                    mediaFile = hashedName;
                                    break;
                                }
                            }
                        }

                        // Strategy 5: Use assetPointerMap (for size-matched images)
                        // The Python code built a mapping from asset_pointer to filename during HTML generation
                        if (!mediaFile && assetPointer && assetPointerMap) {
                            mediaFile = assetPointerMap[assetPointer];
                        }

                        if (mediaFile) {
                            html += `<img src="media/${mediaFile}" alt="Generated Image" loading="lazy" style="max-width: 100%; height: auto; display: block; margin: 10px 0;">`;
                        } else {
                            html += `<p><em>[Image: ${genId || fileId || 'unknown'}]</em></p>`;
                        }
                    }
                });

            } else if (content.content_type === 'code') {
                const language = content.language || 'plaintext';
                const code = content.text || '';
                html = `<pre><code class="language-${language}">${escapeHtml(code)}</code></pre>`;
            }

            return html;
        }

        // Render a message
        function renderMessage(nodeId, nodeData) {
            const message = nodeData.message;
            if (!message) return '';

            const author = message.author?.role || 'unknown';
            const content = message.content;
            const createTime = message.create_time;
            const metadata = message.metadata || {};

            // Skip empty messages (no content or empty content)
            if (!content) return '';

            // Check if content is empty based on type
            if (content.content_type === 'text' || content.content_type === 'multimodal_text') {
                const parts = content.parts || [];
                // Skip if no parts or all parts are empty
                const hasContent = parts.some(part => {
                    if (typeof part === 'string') {
                        return part.trim().length > 0;
                    }
                    return part && (part.content_type === 'image_asset_pointer' || part.asset_pointer);
                });
                if (!hasContent) return '';
            }

            let messageClass = '';
            let authorLabel = author.charAt(0).toUpperCase() + author.slice(1);

            if (author === 'user') {
                messageClass = 'user';
                authorLabel = 'üë§ User';
            } else if (author === 'assistant') {
                messageClass = 'assistant';
                authorLabel = 'ü§ñ Assistant';
            } else if (author === 'tool') {
                messageClass = 'tool';
                authorLabel = 'üîß Tool: ' + (message.author.name || 'Unknown');
            } else if (author === 'system') {
                messageClass = 'tool';
                authorLabel = '‚öôÔ∏è System';
            }

            const timestamp = formatTimestamp(createTime);
            const contentHtml = renderMessageContent(content);

            let html = `
                <div class="message ${messageClass}" id="msg-${nodeId}">
                    <div class="message-header">
                        <span class="message-author">${authorLabel}</span>
                        <span class="message-time">${timestamp}</span>
                    </div>
                    <div class="message-content">
                        ${contentHtml}
                    </div>
            `;

            // Show metadata if interesting
            if (metadata.model_slug) {
                html += `<div class="metadata-section">Model: ${metadata.model_slug}</div>`;
            }

            html += '</div>';
            return html;
        }

        // Render the conversation
        function renderConversation() {
            const container = document.getElementById('conversation-container');

            if (!conversationData || !conversationData.mapping) {
                container.innerHTML = '<p class="loading">No conversation data found.</p>';
                return;
            }

            let html = '';
            const mapping = conversationData.mapping;

            // Find root node
            let rootId = null;
            for (const [nodeId, nodeData] of Object.entries(mapping)) {
                if (!nodeData.parent) {
                    rootId = nodeId;
                    break;
                }
            }

            // Traverse tree and render messages
            function traverse(nodeId) {
                const nodeData = mapping[nodeId];
                if (!nodeData) return;

                // Render this message
                html += renderMessage(nodeId, nodeData);

                // Render children
                const children = nodeData.children || [];
                children.forEach(childId => traverse(childId));
            }

            if (rootId) {
                traverse(rootId);
            } else {
                // Fallback: render all messages
                for (const [nodeId, nodeData] of Object.entries(mapping)) {
                    html += renderMessage(nodeId, nodeData);
                }
            }

            container.innerHTML = html;

            // Apply syntax highlighting to code blocks
            document.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightElement(block);
            });
        }

        // Lightbox functionality
        let currentImageIndex = 0;
        let allImages = [];

        function initializeLightbox() {
            // Collect all images in the conversation
            allImages = Array.from(document.querySelectorAll('.message-content img'));

            // Add click handlers to all images
            allImages.forEach((img, index) => {
                img.addEventListener('click', () => openLightbox(index));
                img.style.cursor = 'pointer';
            });

            // Add keyboard navigation
            document.addEventListener('keydown', (e) => {
                const lightbox = document.getElementById('lightbox');
                if (!lightbox || !lightbox.classList.contains('active')) return;

                if (e.key === 'Escape') {
                    closeLightbox();
                } else if (e.key === 'ArrowLeft') {
                    navigateLightbox(-1);
                } else if (e.key === 'ArrowRight') {
                    navigateLightbox(1);
                }
            });
        }

        function openLightbox(index) {
            currentImageIndex = index;
            const lightbox = document.getElementById('lightbox');
            const lightboxImg = document.getElementById('lightbox-img');
            const caption = document.getElementById('lightbox-caption');

            if (!lightbox || !lightboxImg) {
                // Create lightbox if it doesn't exist
                createLightboxElements();
                return openLightbox(index);
            }

            lightbox.classList.add('active');
            lightboxImg.src = allImages[index].src;

            // Update caption with image info
            const imgAlt = allImages[index].alt || 'Image';
            caption.textContent = `${index + 1} / ${allImages.length}`;

            updateLightboxButtons();
            document.body.style.overflow = 'hidden'; // Prevent background scrolling
        }

        function closeLightbox() {
            const lightbox = document.getElementById('lightbox');
            if (lightbox) {
                lightbox.classList.remove('active');
                document.body.style.overflow = ''; // Restore scrolling
            }
        }

        function navigateLightbox(direction) {
            const newIndex = currentImageIndex + direction;
            if (newIndex >= 0 && newIndex < allImages.length) {
                openLightbox(newIndex);
            }
        }

        function updateLightboxButtons() {
            const prevBtn = document.getElementById('lightbox-prev');
            const nextBtn = document.getElementById('lightbox-next');

            if (prevBtn) {
                prevBtn.disabled = currentImageIndex === 0;
            }
            if (nextBtn) {
                nextBtn.disabled = currentImageIndex === allImages.length - 1;
            }
        }

        function createLightboxElements() {
            // Create lightbox HTML structure
            const lightboxHTML = `
                <div id="lightbox" class="lightbox">
                    <button id="lightbox-close" class="lightbox-close" onclick="closeLightbox()">&times;</button>
                    <img id="lightbox-img" class="lightbox-content" alt="Lightbox image">
                    <div id="lightbox-caption" class="lightbox-caption"></div>
                    <button id="lightbox-prev" class="lightbox-prev" onclick="navigateLightbox(-1)">&#10094;</button>
                    <button id="lightbox-next" class="lightbox-next" onclick="navigateLightbox(1)">&#10095;</button>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', lightboxHTML);

            // Add click-outside-to-close
            document.getElementById('lightbox').addEventListener('click', (e) => {
                if (e.target.id === 'lightbox') {
                    closeLightbox();
                }
            });
        }

        function groupImagesInMessages() {
            // Find all messages and group consecutive images into galleries
            const messages = document.querySelectorAll('.message-content');

            messages.forEach(messageContent => {
                const images = Array.from(messageContent.querySelectorAll('img'));
                if (images.length <= 1) return; // Skip if 0 or 1 image

                // Create gallery container
                const gallery = document.createElement('div');
                gallery.className = 'message-images';

                // Move images into gallery
                images.forEach(img => {
                    // Clone the image to preserve it
                    const imgClone = img.cloneNode(true);
                    gallery.appendChild(imgClone);
                    // Remove original (will be replaced by gallery)
                    img.remove();
                });

                // Add gallery to message
                messageContent.appendChild(gallery);
            });
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            renderConversation();

            // Wait a bit for images to be rendered, then set up lightbox
            setTimeout(() => {
                groupImagesInMessages();
                initializeLightbox();
            }, 100);
        });
        '''

    def _build_asset_pointer_map(self, conversation, media_files, media_mapping):
        """
        Build a mapping from asset_pointer to actual hashed filename.

        Strategy:
        - Collect all asset_pointers with their size_bytes from the conversation
        - Group available media files by their actual file size
        - Match asset_pointers to files based on size
        - For same-size files, assign in order of appearance

        Args:
            conversation: Conversation dict
            media_files: List of hashed filenames (in media/ folder)
            media_mapping: Dict of original -> hashed filenames

        Returns:
            Dict mapping asset_pointer to hashed filename
        """
        import os
        import re
        asset_map = {}

        # Step 1: Get actual file sizes from media_mapping
        # We need to get the size from _media_files (full paths) in conversation
        size_to_files = {}  # file_size -> [hashed_filename, ...]

        # Get full paths from conversation (these have actual file sizes)
        full_paths = conversation.get('_media_files', [])

        for full_path in full_paths:
            basename = os.path.basename(full_path)
            # Find this file in media_mapping (by matching basename to hashed names)
            for original, hashed in media_mapping.items():
                if basename == original or hashed.endswith(basename):
                    # Try to get actual file size if path exists
                    if os.path.exists(full_path):
                        size = os.path.getsize(full_path)
                        if size not in size_to_files:
                            size_to_files[size] = []
                        if hashed not in size_to_files[size]:
                            size_to_files[size].append(hashed)
                    break

        # Step 2: Collect asset_pointers with their sizes from conversation
        # Process in traversal order to maintain sequence
        mapping = conversation.get('mapping', {})

        # Find root and traverse in order
        root_id = None
        for node_id, node_data in mapping.items():
            if node_data.get('parent') is None:
                root_id = node_id
                break

        asset_pointers_ordered = []  # List of (asset_pointer, size_bytes)

        def traverse(node_id):
            node_data = mapping.get(node_id, {})
            msg = node_data.get('message')

            if msg:
                content = msg.get('content', {})
                if content.get('content_type') == 'multimodal_text':
                    parts = content.get('parts', [])
                    for part in parts:
                        if isinstance(part, dict):
                            asset_pointer = part.get('asset_pointer', '')
                            if asset_pointer and asset_pointer.startswith('file-service://'):
                                size_bytes = part.get('size_bytes')
                                if size_bytes:
                                    asset_pointers_ordered.append((asset_pointer, size_bytes))

            # Traverse children
            for child_id in node_data.get('children', []):
                traverse(child_id)

        if root_id:
            traverse(root_id)

        # Step 3: Match asset_pointers to files by size, in order
        size_counters = {}  # Track which file index to use for each size

        for asset_pointer, size_bytes in asset_pointers_ordered:
            if size_bytes in size_to_files:
                files_with_size = size_to_files[size_bytes]

                # Get next file for this size
                if size_bytes not in size_counters:
                    size_counters[size_bytes] = 0

                idx = size_counters[size_bytes]
                if idx < len(files_with_size):
                    asset_map[asset_pointer] = files_with_size[idx]
                    size_counters[size_bytes] += 1

        return asset_map

    def _format_timestamp(self, timestamp):
        """Format Unix timestamp to readable date."""
        if not timestamp:
            return "Unknown"
        dt = datetime.fromtimestamp(timestamp)
        return dt.strftime("%Y-%m-%d %H:%M:%S")

    def _escape_html(self, text):
        """Escape HTML special characters."""
        if not text:
            return ""
        return (str(text)
                .replace("&", "&amp;")
                .replace("<", "&lt;")
                .replace(">", "&gt;")
                .replace('"', "&quot;")
                .replace("'", "&#39;"))

    def generate_index_html(self, conversations, output_dir):
        """
        Generate master index.html listing all conversations with enhanced filtering.

        Args:
            conversations: List of conversation dicts
            output_dir: Output directory path

        Returns:
            HTML string
        """
        # Build conversation list with extended metadata
        conv_list = []
        for conv in conversations:
            title = conv.get('title', 'Untitled')
            create_time = conv.get('create_time')
            conv_id = conv.get('conversation_id') or conv.get('id', 'unknown')

            # Count messages and calculate metrics
            mapping = conv.get('mapping', {})
            message_count = 0
            total_words = 0
            code_block_count = 0

            for node in mapping.values():
                msg = node.get('message')
                if not msg:
                    continue

                message_count += 1
                content = msg.get('content', {})

                # Extract text content
                if content.get('content_type') == 'text':
                    parts = content.get('parts', [])
                    for part in parts:
                        if isinstance(part, str):
                            words = part.split()
                            total_words += len(words)
                            # Count code blocks
                            code_block_count += part.count('```') // 2

                # Also check multimodal_text for audio transcripts etc
                elif content.get('content_type') == 'multimodal_text':
                    parts = content.get('parts', [])
                    for part in parts:
                        if isinstance(part, str):
                            total_words += len(part.split())
                        elif isinstance(part, dict) and part.get('content_type') == 'audio_transcription':
                            text = part.get('text', '')
                            if text:
                                total_words += len(text.split())

            # Calculate code percentage
            code_percentage = (code_block_count / message_count * 100) if message_count > 0 else 0

            # Check for media/assets
            has_media = bool(conv.get('_media_files'))
            has_assets = '_assets' in conv

            # Get folder name
            folder_name = conv.get('_folder_name', '')

            if folder_name:
                conv_list.append({
                    'title': title,
                    'folder_name': folder_name,
                    'create_time': create_time,
                    'message_count': message_count,
                    'word_count': total_words,
                    'code_percentage': code_percentage,
                    'has_media': has_media,
                    'has_assets': has_assets,
                    'conv_id': conv_id
                })

        # Sort by create_time (newest first)
        conv_list.sort(key=lambda x: x['create_time'] or 0, reverse=True)

        # Serialize conversation data for JavaScript
        import json as json_lib
        conversations_json = json_lib.dumps(conv_list, ensure_ascii=False)

        # Generate HTML cards (JavaScript will handle filtering)
        conversations_html = ''
        for conv in conv_list:
            date_str = self._format_timestamp(conv['create_time']) if conv['create_time'] else 'Unknown'
            media_badge = 'üñºÔ∏è Media' if conv['has_media'] else ''
            assets_badge = 'üìÑ Assets' if conv['has_assets'] else ''
            code_badge = f'üíª {conv["code_percentage"]:.0f}% code' if conv['code_percentage'] > 20 else ''

            conversations_html += f'''
                <div class="conversation-card"
                     data-messages="{conv['message_count']}"
                     data-words="{conv['word_count']}"
                     data-code="{conv['code_percentage']:.1f}"
                     data-timestamp="{conv['create_time'] or 0}"
                     data-has-media="{str(conv['has_media']).lower()}"
                     data-has-assets="{str(conv['has_assets']).lower()}">
                    <a href="{conv['folder_name']}/conversation.html" class="conversation-link">
                        <h3>{self._escape_html(conv['title'])}</h3>
                        <div class="conversation-meta">
                            <span>üìÖ {date_str}</span>
                            <span>üí¨ {conv['message_count']} messages</span>
                            <span>üìù {conv['word_count']:,} words</span>
                            {f'<span class="badge">{media_badge}</span>' if media_badge else ''}
                            {f'<span class="badge">{assets_badge}</span>' if assets_badge else ''}
                            {f'<span class="badge code-badge">{code_badge}</span>' if code_badge else ''}
                        </div>
                    </a>
                </div>
            '''

        html = f'''<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenAI Export - Conversations</title>
    <style>
{self._get_index_css()}
    </style>

    <!-- Detect dark mode preference BEFORE page render to avoid flash -->
    <script>
        (function() {{
            const stored = localStorage.getItem('darkMode');
            const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;

            // Priority: localStorage > system preference
            if (stored === 'enabled' || (stored === null && prefersDark)) {{
                document.documentElement.classList.add('dark-mode');
            }}
        }})();
    </script>
</head>
<body>
    <div class="container">
        <header>
            <h1>üìö OpenAI Conversation Export</h1>
            <div class="stats">
                <span id="stat-total">Total: {len(conv_list)}</span>
                <span id="stat-showing">Showing: {len(conv_list)}</span>
                <span>Media: {sum(1 for c in conv_list if c['has_media'])}</span>
                <span>Assets: {sum(1 for c in conv_list if c['has_assets'])}</span>
            </div>

            <div class="search-section">
                <div class="search-input-container">
                    <input type="text" id="search" placeholder="üîç Search title or content..." autocomplete="off">
                    <button onclick="clearSearch()" class="btn-clear" title="Clear search">‚úï</button>
                </div>
                <div id="search-history" class="search-history"></div>
            </div>

            <details class="filters-panel">
                <summary>üîç Advanced Filters</summary>
                <div class="filters-grid">
                    <div class="filter-group">
                        <label>Messages</label>
                        <input type="number" id="filter-messages-min" placeholder="Min" min="0">
                        <input type="number" id="filter-messages-max" placeholder="Max" min="0">
                    </div>
                    <div class="filter-group">
                        <label>Words</label>
                        <input type="number" id="filter-words-min" placeholder="Min" min="0">
                        <input type="number" id="filter-words-max" placeholder="Max" min="0">
                    </div>
                    <div class="filter-group">
                        <label>Date Range</label>
                        <input type="date" id="filter-date-start">
                        <input type="date" id="filter-date-end">
                    </div>
                    <div class="filter-group">
                        <label>
                            <input type="checkbox" id="filter-exclude-code"> Exclude code-heavy (>50%)
                        </label>
                        <label>
                            <input type="checkbox" id="filter-has-media"> Has media only
                        </label>
                    </div>
                    <div class="filter-actions">
                        <button onclick="applyFilters()" class="btn-apply">Apply Filters</button>
                        <button onclick="resetFilters()" class="btn-reset">Reset</button>
                    </div>
                </div>
            </details>

            <button onclick="toggleDarkMode()" class="btn-dark-mode">üåì Toggle Theme</button>
        </header>

        <main id="conversations-container">
            {conversations_html}
        </main>

        <footer>
            <p>Generated by <a href="https://github.com/temnoon/openai-export-parser" target="_blank">OpenAI Export Parser</a></p>
        </footer>
    </div>

    <!-- Embedded conversation data for JavaScript filtering -->
    <script id="conversations-data" type="application/json">
{conversations_json}
    </script>

    <script>
{self._get_index_javascript()}
    </script>
</body>
</html>'''

        return html

    def _get_index_css(self):
        """Get CSS for index page."""
        return '''
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f5f5f5;
            --text-primary: #212121;
            --text-secondary: #666666;
            --border-color: #e0e0e0;
            --accent-color: #1976d2;
            --card-bg: #ffffff;
            --card-hover: #f5f5f5;
        }

        html.dark-mode,
        html.dark-mode body {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --text-primary: #e0e0e0;
            --text-secondary: #b0b0b0;
            --border-color: #444444;
            --accent-color: #64b5f6;
            --card-bg: #2d2d2d;
            --card-hover: #3d3d3d;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            transition: background-color 0.3s, color 0.3s;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background-color: var(--bg-secondary);
            padding: 40px;
            border-radius: 12px;
            margin-bottom: 30px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 20px;
            color: var(--accent-color);
        }

        .stats {
            display: flex;
            gap: 30px;
            margin-bottom: 20px;
            font-size: 1.1em;
            color: var(--text-secondary);
        }

        .filters {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        #search {
            flex: 1;
            padding: 12px 20px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 1em;
            background-color: var(--bg-primary);
            color: var(--text-primary);
        }

        .btn-dark-mode {
            padding: 12px 24px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 1em;
            transition: all 0.2s;
        }

        .btn-dark-mode:hover {
            background-color: var(--accent-color);
            color: white;
        }

        /* Enhanced filter UI styles */
        .search-section {
            margin-bottom: 20px;
        }

        .search-input-container {
            position: relative;
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .btn-clear {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 1.2em;
            padding: 5px 10px;
        }

        .btn-clear:hover {
            color: var(--text-primary);
        }

        .search-history {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            min-height: 20px;
        }

        .search-history-item {
            padding: 5px 12px;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s;
        }

        .search-history-item:hover {
            background-color: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }

        .filters-panel {
            margin: 20px 0;
            padding: 15px;
            background-color: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
        }

        .filters-panel summary {
            cursor: pointer;
            font-weight: 600;
            padding: 5px;
            user-select: none;
        }

        .filters-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 15px;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .filter-group label {
            font-weight: 500;
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        .filter-group input[type="number"],
        .filter-group input[type="date"] {
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-size: 0.9em;
        }

        .filter-group input[type="checkbox"] {
            margin-right: 8px;
        }

        .filter-actions {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .btn-apply, .btn-reset {
            padding: 10px 20px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s;
        }

        .btn-apply {
            background-color: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }

        .btn-apply:hover {
            opacity: 0.9;
        }

        .btn-reset {
            background-color: var(--bg-secondary);
            color: var(--text-primary);
        }

        .btn-reset:hover {
            background-color: var(--border-color);
        }

        .code-badge {
            background-color: #9c27b0;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.85em;
        }

        main {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }

        .conversation-card {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .conversation-card:hover {
            background-color: var(--card-hover);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }

        .conversation-link {
            text-decoration: none;
            color: inherit;
            display: block;
        }

        .conversation-card h3 {
            font-size: 1.2em;
            margin-bottom: 10px;
            color: var(--accent-color);
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
        }

        .conversation-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        .badge {
            background-color: var(--accent-color);
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.85em;
        }

        footer {
            padding: 20px;
            text-align: center;
            color: var(--text-secondary);
            border-top: 1px solid var(--border-color);
        }

        footer a {
            color: var(--accent-color);
            text-decoration: none;
        }

        @media (max-width: 768px) {
            header h1 {
                font-size: 1.8em;
            }

            .stats {
                flex-direction: column;
                gap: 10px;
            }

            main {
                grid-template-columns: 1fr;
            }
        }
        '''

    def _get_index_javascript(self):
        """Get JavaScript for index page with enhanced filtering."""
        return '''
        // Load conversation data
        const conversationsData = JSON.parse(document.getElementById('conversations-data').textContent);
        const MAX_SEARCH_HISTORY = 10;

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            loadSearchHistory();
            restoreLastSearch();
            setupSearchInput();
        });

        function toggleDarkMode() {
            document.documentElement.classList.toggle('dark-mode');
            const isDark = document.documentElement.classList.contains('dark-mode');
            localStorage.setItem('darkMode', isDark ? 'enabled' : 'disabled');
        }

        function setupSearchInput() {
            const searchInput = document.getElementById('search');
            let searchTimeout;

            searchInput.addEventListener('input', function() {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    filterConversations();
                    saveCurrentSearch();
                }, 300);  // Debounce search
            });

            searchInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    const searchTerm = searchInput.value.trim();
                    if (searchTerm) {
                        addToSearchHistory(searchTerm);
                    }
                }
            });
        }

        function filterConversations() {
            const searchTerm = document.getElementById('search').value.toLowerCase();
            const cards = document.querySelectorAll('.conversation-card');
            let visibleCount = 0;

            cards.forEach(card => {
                const title = card.querySelector('h3').textContent.toLowerCase();
                const convData = findConversationData(title);

                // Check if matches search
                let matchesSearch = true;
                if (searchTerm) {
                    matchesSearch = title.includes(searchTerm) ||
                                   (convData && convData.search_text && convData.search_text.includes(searchTerm));
                }

                if (matchesSearch) {
                    card.style.display = 'block';
                    visibleCount++;
                } else {
                    card.style.display = 'none';
                }
            });

            updateVisibleCount(visibleCount);
        }

        function findConversationData(title) {
            return conversationsData.find(c => c.title.toLowerCase() === title.toLowerCase());
        }

        function applyFilters() {
            const minMessages = parseInt(document.getElementById('filter-messages-min').value) || 0;
            const maxMessages = parseInt(document.getElementById('filter-messages-max').value) || Infinity;
            const minWords = parseInt(document.getElementById('filter-words-min').value) || 0;
            const maxWords = parseInt(document.getElementById('filter-words-max').value) || Infinity;
            const startDate = document.getElementById('filter-date-start').value;
            const endDate = document.getElementById('filter-date-end').value;
            const excludeCode = document.getElementById('filter-exclude-code').checked;
            const hasMediaOnly = document.getElementById('filter-has-media').checked;
            const searchTerm = document.getElementById('search').value.toLowerCase();

            const cards = document.querySelectorAll('.conversation-card');
            let visibleCount = 0;

            cards.forEach(card => {
                const messages = parseInt(card.dataset.messages) || 0;
                const words = parseInt(card.dataset.words) || 0;
                const code = parseFloat(card.dataset.code) || 0;
                const timestamp = parseInt(card.dataset.timestamp) || 0;
                const hasMedia = card.dataset.hasMedia === 'true';
                const title = card.querySelector('h3').textContent.toLowerCase();
                const convData = findConversationData(title);

                let visible = true;

                // Search filter (title only)
                if (searchTerm) {
                    const matchesSearch = title.includes(searchTerm);
                    if (!matchesSearch) visible = false;
                }

                // Message count filter
                if (messages < minMessages || messages > maxMessages) visible = false;

                // Word count filter
                if (words < minWords || words > maxWords) visible = false;

                // Date range filter
                if (startDate) {
                    const start = new Date(startDate).getTime() / 1000;
                    if (timestamp < start) visible = false;
                }
                if (endDate) {
                    const end = new Date(endDate).getTime() / 1000;
                    if (timestamp > end) visible = false;
                }

                // Code exclusion filter
                if (excludeCode && code > 50) visible = false;

                // Media filter
                if (hasMediaOnly && !hasMedia) visible = false;

                card.style.display = visible ? 'block' : 'none';
                if (visible) visibleCount++;
            });

            updateVisibleCount(visibleCount);
        }

        function resetFilters() {
            document.getElementById('filter-messages-min').value = '';
            document.getElementById('filter-messages-max').value = '';
            document.getElementById('filter-words-min').value = '';
            document.getElementById('filter-words-max').value = '';
            document.getElementById('filter-date-start').value = '';
            document.getElementById('filter-date-end').value = '';
            document.getElementById('filter-exclude-code').checked = false;
            document.getElementById('filter-has-media').checked = false;

            filterConversations();  // Apply just the search term if any
        }

        function updateVisibleCount(count) {
            const total = document.querySelectorAll('.conversation-card').length;
            document.getElementById('stat-showing').textContent = `Showing: ${count}`;
        }

        function clearSearch() {
            document.getElementById('search').value = '';
            localStorage.removeItem('lastSearch');
            filterConversations();
        }

        function saveCurrentSearch() {
            const searchTerm = document.getElementById('search').value;
            if (searchTerm.trim()) {
                localStorage.setItem('lastSearch', searchTerm);
            }
        }

        function restoreLastSearch() {
            const lastSearch = localStorage.getItem('lastSearch');
            if (lastSearch) {
                document.getElementById('search').value = lastSearch;
                filterConversations();
            }
        }

        function loadSearchHistory() {
            const history = JSON.parse(localStorage.getItem('searchHistory') || '[]');
            const historyContainer = document.getElementById('search-history');

            historyContainer.innerHTML = '';
            history.slice(0, MAX_SEARCH_HISTORY).forEach(term => {
                const item = document.createElement('span');
                item.className = 'search-history-item';
                item.textContent = term;
                item.onclick = () => {
                    document.getElementById('search').value = term;
                    filterConversations();
                };
                historyContainer.appendChild(item);
            });
        }

        function addToSearchHistory(term) {
            let history = JSON.parse(localStorage.getItem('searchHistory') || '[]');

            // Remove if already exists
            history = history.filter(t => t !== term);

            // Add to beginning
            history.unshift(term);

            // Limit size
            history = history.slice(0, MAX_SEARCH_HISTORY);

            localStorage.setItem('searchHistory', JSON.stringify(history));
            loadSearchHistory();
        }
        '''
